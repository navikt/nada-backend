// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: dataproduct_access_requests.sql

package gensql

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const approveAccessRequest = `-- name: ApproveAccessRequest :exec
UPDATE dataproduct_access_request
SET status = 'approved',
    granter = $1,
    closed = NOW()
WHERE id = $2
`

type ApproveAccessRequestParams struct {
	Granter sql.NullString
	ID      uuid.UUID
}

func (q *Queries) ApproveAccessRequest(ctx context.Context, arg ApproveAccessRequestParams) error {
	_, err := q.db.ExecContext(ctx, approveAccessRequest, arg.Granter, arg.ID)
	return err
}

const createAccessRequestForDataproduct = `-- name: CreateAccessRequestForDataproduct :one
INSERT INTO dataproduct_access_request (dataproduct_id,
                                        "subject",
                                        "owner",
                                        "expires",
                                        polly_documentation_id)
VALUES ($1,
        LOWER($2),
        LOWER($3),
        $4,
        $5)
RETURNING id, dataproduct_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
`

type CreateAccessRequestForDataproductParams struct {
	DataproductID        uuid.UUID
	Subject              string
	Owner                string
	Expires              sql.NullTime
	PollyDocumentationID uuid.NullUUID
}

func (q *Queries) CreateAccessRequestForDataproduct(ctx context.Context, arg CreateAccessRequestForDataproductParams) (DataproductAccessRequest, error) {
	row := q.db.QueryRowContext(ctx, createAccessRequestForDataproduct,
		arg.DataproductID,
		arg.Subject,
		arg.Owner,
		arg.Expires,
		arg.PollyDocumentationID,
	)
	var i DataproductAccessRequest
	err := row.Scan(
		&i.ID,
		&i.DataproductID,
		&i.Subject,
		&i.Owner,
		&i.PollyDocumentationID,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.Status,
		&i.Closed,
		&i.Granter,
		&i.Reason,
	)
	return i, err
}

const deleteAccessRequest = `-- name: DeleteAccessRequest :exec
DELETE FROM dataproduct_access_request
WHERE id = $1
`

func (q *Queries) DeleteAccessRequest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAccessRequest, id)
	return err
}

const denyAccessRequest = `-- name: DenyAccessRequest :exec
UPDATE dataproduct_access_request
SET status = 'denied',
    granter = $1,
    reason = $2,
    closed = NOW()
WHERE id = $3
`

type DenyAccessRequestParams struct {
	Granter sql.NullString
	Reason  sql.NullString
	ID      uuid.UUID
}

func (q *Queries) DenyAccessRequest(ctx context.Context, arg DenyAccessRequestParams) error {
	_, err := q.db.ExecContext(ctx, denyAccessRequest, arg.Granter, arg.Reason, arg.ID)
	return err
}

const getAccessRequest = `-- name: GetAccessRequest :one
SELECT id, dataproduct_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
FROM dataproduct_access_request
WHERE id = $1
`

func (q *Queries) GetAccessRequest(ctx context.Context, id uuid.UUID) (DataproductAccessRequest, error) {
	row := q.db.QueryRowContext(ctx, getAccessRequest, id)
	var i DataproductAccessRequest
	err := row.Scan(
		&i.ID,
		&i.DataproductID,
		&i.Subject,
		&i.Owner,
		&i.PollyDocumentationID,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.Status,
		&i.Closed,
		&i.Granter,
		&i.Reason,
	)
	return i, err
}

const listAccessRequestsForDataproduct = `-- name: ListAccessRequestsForDataproduct :many
SELECT id, dataproduct_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
FROM dataproduct_access_request
WHERE dataproduct_id = $1 AND status = 'pending'
`

func (q *Queries) ListAccessRequestsForDataproduct(ctx context.Context, dataproductID uuid.UUID) ([]DataproductAccessRequest, error) {
	rows, err := q.db.QueryContext(ctx, listAccessRequestsForDataproduct, dataproductID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DataproductAccessRequest{}
	for rows.Next() {
		var i DataproductAccessRequest
		if err := rows.Scan(
			&i.ID,
			&i.DataproductID,
			&i.Subject,
			&i.Owner,
			&i.PollyDocumentationID,
			&i.LastModified,
			&i.Created,
			&i.Expires,
			&i.Status,
			&i.Closed,
			&i.Granter,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccessRequestsForOwner = `-- name: ListAccessRequestsForOwner :many
SELECT id, dataproduct_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
FROM dataproduct_access_request
WHERE "owner" = ANY ($1::text[])
`

func (q *Queries) ListAccessRequestsForOwner(ctx context.Context, owner []string) ([]DataproductAccessRequest, error) {
	rows, err := q.db.QueryContext(ctx, listAccessRequestsForOwner, pq.Array(owner))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DataproductAccessRequest{}
	for rows.Next() {
		var i DataproductAccessRequest
		if err := rows.Scan(
			&i.ID,
			&i.DataproductID,
			&i.Subject,
			&i.Owner,
			&i.PollyDocumentationID,
			&i.LastModified,
			&i.Created,
			&i.Expires,
			&i.Status,
			&i.Closed,
			&i.Granter,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccessRequest = `-- name: UpdateAccessRequest :one
UPDATE dataproduct_access_request
SET owner                  = $1,
    polly_documentation_id = $2,
    expires = $3
WHERE id = $4
RETURNING id, dataproduct_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
`

type UpdateAccessRequestParams struct {
	Owner                string
	PollyDocumentationID uuid.NullUUID
	Expires              sql.NullTime
	ID                   uuid.UUID
}

func (q *Queries) UpdateAccessRequest(ctx context.Context, arg UpdateAccessRequestParams) (DataproductAccessRequest, error) {
	row := q.db.QueryRowContext(ctx, updateAccessRequest,
		arg.Owner,
		arg.PollyDocumentationID,
		arg.Expires,
		arg.ID,
	)
	var i DataproductAccessRequest
	err := row.Scan(
		&i.ID,
		&i.DataproductID,
		&i.Subject,
		&i.Owner,
		&i.PollyDocumentationID,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.Status,
		&i.Closed,
		&i.Granter,
		&i.Reason,
	)
	return i, err
}
