// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: dataset_access_requests.sql

package gensql

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const approveAccessRequest = `-- name: ApproveAccessRequest :exec
UPDATE dataset_access_requests
SET status = 'approved',
    granter = $1,
    closed = NOW()
WHERE id = $2
`

type ApproveAccessRequestParams struct {
	Granter sql.NullString
	ID      uuid.UUID
}

func (q *Queries) ApproveAccessRequest(ctx context.Context, arg ApproveAccessRequestParams) error {
	_, err := q.db.ExecContext(ctx, approveAccessRequest, arg.Granter, arg.ID)
	return err
}

const createAccessRequestForDataset = `-- name: CreateAccessRequestForDataset :one
INSERT INTO dataset_access_requests (dataset_id,
                                        "subject",
                                        "owner",
                                        "expires",
                                        polly_documentation_id)
VALUES ($1,
        LOWER($2),
        LOWER($3),
        $4,
        $5)
RETURNING id, dataset_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
`

type CreateAccessRequestForDatasetParams struct {
	DatasetID            uuid.UUID
	Subject              string
	Owner                string
	Expires              sql.NullTime
	PollyDocumentationID uuid.NullUUID
}

func (q *Queries) CreateAccessRequestForDataset(ctx context.Context, arg CreateAccessRequestForDatasetParams) (DatasetAccessRequest, error) {
	row := q.db.QueryRowContext(ctx, createAccessRequestForDataset,
		arg.DatasetID,
		arg.Subject,
		arg.Owner,
		arg.Expires,
		arg.PollyDocumentationID,
	)
	var i DatasetAccessRequest
	err := row.Scan(
		&i.ID,
		&i.DatasetID,
		&i.Subject,
		&i.Owner,
		&i.PollyDocumentationID,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.Status,
		&i.Closed,
		&i.Granter,
		&i.Reason,
	)
	return i, err
}

const deleteAccessRequest = `-- name: DeleteAccessRequest :exec
DELETE FROM dataset_access_requests
WHERE id = $1
`

func (q *Queries) DeleteAccessRequest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAccessRequest, id)
	return err
}

const denyAccessRequest = `-- name: DenyAccessRequest :exec
UPDATE dataset_access_requests
SET status = 'denied',
    granter = $1,
    reason = $2,
    closed = NOW()
WHERE id = $3
`

type DenyAccessRequestParams struct {
	Granter sql.NullString
	Reason  sql.NullString
	ID      uuid.UUID
}

func (q *Queries) DenyAccessRequest(ctx context.Context, arg DenyAccessRequestParams) error {
	_, err := q.db.ExecContext(ctx, denyAccessRequest, arg.Granter, arg.Reason, arg.ID)
	return err
}

const getAccessRequest = `-- name: GetAccessRequest :one
SELECT id, dataset_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
FROM dataset_access_requests
WHERE id = $1
`

func (q *Queries) GetAccessRequest(ctx context.Context, id uuid.UUID) (DatasetAccessRequest, error) {
	row := q.db.QueryRowContext(ctx, getAccessRequest, id)
	var i DatasetAccessRequest
	err := row.Scan(
		&i.ID,
		&i.DatasetID,
		&i.Subject,
		&i.Owner,
		&i.PollyDocumentationID,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.Status,
		&i.Closed,
		&i.Granter,
		&i.Reason,
	)
	return i, err
}

const listAccessRequestsForDataset = `-- name: ListAccessRequestsForDataset :many
SELECT id, dataset_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
FROM dataset_access_requests
WHERE dataset_id = $1 AND status = 'pending'
`

func (q *Queries) ListAccessRequestsForDataset(ctx context.Context, datasetID uuid.UUID) ([]DatasetAccessRequest, error) {
	rows, err := q.db.QueryContext(ctx, listAccessRequestsForDataset, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasetAccessRequest{}
	for rows.Next() {
		var i DatasetAccessRequest
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.Subject,
			&i.Owner,
			&i.PollyDocumentationID,
			&i.LastModified,
			&i.Created,
			&i.Expires,
			&i.Status,
			&i.Closed,
			&i.Granter,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccessRequestsForOwner = `-- name: ListAccessRequestsForOwner :many
SELECT id, dataset_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
FROM dataset_access_requests
WHERE "owner" = ANY ($1::text[])
`

func (q *Queries) ListAccessRequestsForOwner(ctx context.Context, owner []string) ([]DatasetAccessRequest, error) {
	rows, err := q.db.QueryContext(ctx, listAccessRequestsForOwner, pq.Array(owner))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasetAccessRequest{}
	for rows.Next() {
		var i DatasetAccessRequest
		if err := rows.Scan(
			&i.ID,
			&i.DatasetID,
			&i.Subject,
			&i.Owner,
			&i.PollyDocumentationID,
			&i.LastModified,
			&i.Created,
			&i.Expires,
			&i.Status,
			&i.Closed,
			&i.Granter,
			&i.Reason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAccessRequest = `-- name: UpdateAccessRequest :one
UPDATE dataset_access_requests
SET owner                  = $1,
    polly_documentation_id = $2,
    expires = $3
WHERE id = $4
RETURNING id, dataset_id, subject, owner, polly_documentation_id, last_modified, created, expires, status, closed, granter, reason
`

type UpdateAccessRequestParams struct {
	Owner                string
	PollyDocumentationID uuid.NullUUID
	Expires              sql.NullTime
	ID                   uuid.UUID
}

func (q *Queries) UpdateAccessRequest(ctx context.Context, arg UpdateAccessRequestParams) (DatasetAccessRequest, error) {
	row := q.db.QueryRowContext(ctx, updateAccessRequest,
		arg.Owner,
		arg.PollyDocumentationID,
		arg.Expires,
		arg.ID,
	)
	var i DatasetAccessRequest
	err := row.Scan(
		&i.ID,
		&i.DatasetID,
		&i.Subject,
		&i.Owner,
		&i.PollyDocumentationID,
		&i.LastModified,
		&i.Created,
		&i.Expires,
		&i.Status,
		&i.Closed,
		&i.Granter,
		&i.Reason,
	)
	return i, err
}
