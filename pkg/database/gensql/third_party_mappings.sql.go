// Code generated by sqlc. DO NOT EDIT.
// source: third_party_mappings.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getDataproductMappings = `-- name: GetDataproductMappings :one
SELECT dataproduct_id, services 
FROM third_party_mappings
WHERE "dataproduct_id" = $1
`

func (q *Queries) GetDataproductMappings(ctx context.Context, dataproductID uuid.UUID) (ThirdPartyMapping, error) {
	row := q.db.QueryRowContext(ctx, getDataproductMappings, dataproductID)
	var i ThirdPartyMapping
	err := row.Scan(&i.DataproductID, pq.Array(&i.Services))
	return i, err
}

const getDataproductsByMapping = `-- name: GetDataproductsByMapping :many
SELECT dataproducts.id, dataproducts.name, dataproducts.description, dataproducts."group", dataproducts.pii, dataproducts.created, dataproducts.last_modified, dataproducts.type, dataproducts.tsv_document, dataproducts.slug, dataproducts.repo, dataproducts.keywords, dataproducts.teamkatalogen_url FROM third_party_mappings 
INNER JOIN dataproducts ON dataproducts.id = third_party_mappings.dataproduct_id
WHERE $1::TEXT = ANY("services")
`

func (q *Queries) GetDataproductsByMapping(ctx context.Context, service string) ([]Dataproduct, error) {
	rows, err := q.db.QueryContext(ctx, getDataproductsByMapping, service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Dataproduct{}
	for rows.Next() {
		var i Dataproduct
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Group,
			&i.Pii,
			&i.Created,
			&i.LastModified,
			&i.Type,
			&i.TsvDocument,
			&i.Slug,
			&i.Repo,
			pq.Array(&i.Keywords),
			&i.TeamkatalogenUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapDataproduct = `-- name: MapDataproduct :exec
INSERT INTO third_party_mappings (
    "dataproduct_id",
    "services"
) VALUES (
    $1,
    $2
) ON CONFLICT ("dataproduct_id") DO UPDATE SET 
    "services" = EXCLUDED.services
`

type MapDataproductParams struct {
	DataproductID uuid.UUID
	Services      []string
}

func (q *Queries) MapDataproduct(ctx context.Context, arg MapDataproductParams) error {
	_, err := q.db.ExecContext(ctx, mapDataproduct, arg.DataproductID, pq.Array(arg.Services))
	return err
}
