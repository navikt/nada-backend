// Code generated by sqlc. DO NOT EDIT.
// source: search.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
)

const search = `-- name: Search :many
SELECT
	element_id::uuid,
	element_type::text,
	ts_rank_cd(tsv_document, query) AS rank,
	ts_headline('norwegian', "description", query, 'MinWords=14, MaxWords=15, MaxFragments=2 FragmentDelimiter=" â€¦ " StartSel="**" StopSel="**"')::text AS excerpt
FROM
	search,
	websearch_to_tsquery('norwegian', $1) query
WHERE
	(
		CASE
			WHEN $2 :: text != '' THEN $2 = ANY(keywords)
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN $1 :: text != '' THEN "tsv_document" @@ query
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN $3 :: text != '' THEN "group" = $3
			ELSE TRUE
		END
	)
ORDER BY rank DESC, created DESC
LIMIT $5 OFFSET $4
`

type SearchParams struct {
	Query   string
	Keyword string
	Grp     string
	Offs    int32
	Lim     int32
}

type SearchRow struct {
	ElementID   uuid.UUID
	ElementType string
	Rank        float32
	Excerpt     string
}

func (q *Queries) Search(ctx context.Context, arg SearchParams) ([]SearchRow, error) {
	rows, err := q.db.QueryContext(ctx, search,
		arg.Query,
		arg.Keyword,
		arg.Grp,
		arg.Offs,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRow{}
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(
			&i.ElementID,
			&i.ElementType,
			&i.Rank,
			&i.Excerpt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
