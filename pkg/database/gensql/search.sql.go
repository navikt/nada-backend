// Code generated by sqlc. DO NOT EDIT.
// source: search.sql

package gensql

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const search = `-- name: Search :many
SELECT
	element_id::uuid,
	element_type::text,
	ts_rank_cd(tsv_document, query) AS rank,
	ts_headline('norwegian', "description", query, 'MinWords=10, MaxWords=20, MaxFragments=2 FragmentDelimiter=" â€¦ " StartSel="((START))" StopSel="((STOP))"')::text AS excerpt
FROM
	search,
	websearch_to_tsquery('norwegian', $1) query
WHERE
	(
		CASE
			WHEN array_length($2::text[], 1) > 0 THEN "element_type" = ANY($2)
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN array_length($3::text[], 1) > 0 THEN "keywords" && $3
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN $1 :: text != '' THEN "tsv_document" @@ query
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN array_length($4::text[], 1) > 0 THEN "group" = ANY($4)
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN array_length($5::text[], 1) > 0 THEN "services" && $5
			ELSE TRUE
		END
	)
ORDER BY rank DESC, created ASC
LIMIT $7 OFFSET $6
`

type SearchParams struct {
	Query   string
	Types   []string
	Keyword []string
	Grp     []string
	Service []string
	Offs    int32
	Lim     int32
}

type SearchRow struct {
	ElementID   uuid.UUID
	ElementType string
	Rank        float32
	Excerpt     string
}

func (q *Queries) Search(ctx context.Context, arg SearchParams) ([]SearchRow, error) {
	rows, err := q.db.QueryContext(ctx, search,
		arg.Query,
		pq.Array(arg.Types),
		pq.Array(arg.Keyword),
		pq.Array(arg.Grp),
		pq.Array(arg.Service),
		arg.Offs,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRow{}
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(
			&i.ElementID,
			&i.ElementType,
			&i.Rank,
			&i.Excerpt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const simpleSearch = `-- name: SimpleSearch :many
SELECT
    "dataproducts"."id" AS "element_id",
    'dataproduct'::text AS "element_type",
    coalesce("dataproducts"."description", '') AS "description",
    "dataproducts"."name",
    "dataproducts"."keywords",
    "dataproducts"."group",
    "dataproducts"."created",
    "dataproducts"."last_modified"
FROM dataproducts
UNION
SELECT
    "s"."id" AS "element_id",
    'story'::text AS "element_type",
    coalesce("s"."description", '') AS "description",
    "s"."name",
    '{}' AS "keywords",
    "s"."group",
    "s"."created",
    "s"."last_modified"
FROM (
         SELECT "id", "name", "group", "created", "last_modified", "keywords",
                (
                    SELECT string_agg("spec"->>'content', ' ')
                    FROM (
                             SELECT "spec"
                             FROM "story_views"
                             WHERE "story_id" = "story"."id"
                               AND "type" IN ('markdown', 'header')
                             ORDER BY "sort" ASC
                         ) "views"
                ) AS "description"
         FROM "stories" "story"
     ) "s"
WHERE similarity($3, name) > 0.05
   OR similarity($3, description) > 0.05
   OR similarity($3, "group") > 0.1
ORDER BY created ASC
LIMIT $2 OFFSET $1
`

type SimpleSearchParams struct {
	Offs  int32
	Lim   int32
	Query string
}

type SimpleSearchRow struct {
	ElementID    uuid.UUID
	ElementType  string
	Description  string
	Name         string
	Keywords     []string
	Group        string
	Created      time.Time
	LastModified time.Time
}

//   OR @query % ANY(keywords)
// ORDER BY similarity(@query, name) DESC, created ASC
func (q *Queries) SimpleSearch(ctx context.Context, arg SimpleSearchParams) ([]SimpleSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, simpleSearch, arg.Offs, arg.Lim, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SimpleSearchRow{}
	for rows.Next() {
		var i SimpleSearchRow
		if err := rows.Scan(
			&i.ElementID,
			&i.ElementType,
			&i.Description,
			&i.Name,
			pq.Array(&i.Keywords),
			&i.Group,
			&i.Created,
			&i.LastModified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
