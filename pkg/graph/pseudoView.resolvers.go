package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/navikt/nada-backend/pkg/auth"
	"github.com/navikt/nada-backend/pkg/bigquery"
	"github.com/navikt/nada-backend/pkg/database"
	"github.com/navikt/nada-backend/pkg/graph/models"
)

// CreateJoinableViews is the resolver for the createJoinableViews field.
func (r *mutationResolver) CreateJoinableViews(ctx context.Context, input models.NewJoinableViews) (string, error) {
	user := auth.GetUser(ctx)
	datasets := []*models.Dataset{}
	for _, dsid := range input.DatasetIDs {
		var dataset *models.Dataset
		dataset, err := r.repo.GetDataset(ctx, dsid)
		if err != nil {
			return "", fmt.Errorf("Failed to find dataset to make joinable view: %v", err)
		}
		dataproduct, err := r.repo.GetDataproduct(ctx, dataset.DataproductID)
		if err != nil {
			return "", fmt.Errorf("Failed to find dataproduct for dataset: %v", err)
		}
		if !user.GoogleGroups.Contains(dataproduct.Owner.Group) {
			access, err := r.repo.ListActiveAccessToDataset(ctx, dataset.ID)
			if err != nil {
				return "", fmt.Errorf("Failed to check dataset access: %v", err)
			}
			accessSet := make(map[string]int)
			for _, da := range access {
				accessSet[da.Subject] = 1
			}
			for _, ugg := range user.GoogleGroups {
				accessSet["group:"+ugg.Email] = 1
			}
			accessSet["user:"+user.Email] = 1
			if len(accessSet) == len(user.GoogleGroups.Emails())+1+len(access) {
				return "", fmt.Errorf("Access denied")
			}
		}
		datasets = append(datasets, dataset)
	}

	datasources := []bigquery.JoinableViewDatasource{}
	pseudoDatasourceIDs := []uuid.UUID{}
	for _, ds := range datasets {
		var refDatasource models.BigQuery
		var pseudoDatasource models.BigQuery
		var err error
		if refDatasource, err = r.repo.GetBigqueryDatasource(ctx, ds.ID, true); err != nil {
			return "", fmt.Errorf("Failed to find reference bigquery datasource: %v", err)
		}

		if pseudoDatasource, err = r.repo.GetBigqueryDatasource(ctx, ds.ID, false); err != nil {
			return "", fmt.Errorf("failed to find bigquery datasource: %v", err)
		}
		datasources = append(datasources, bigquery.JoinableViewDatasource{
			RefDatasource:    &refDatasource,
			PseudoDatasource: &pseudoDatasource,
		})
		pseudoDatasourceIDs = append(pseudoDatasourceIDs, pseudoDatasource.ID)
	}

	projectID, joinableDatasetID, joinableViewsMap, err := r.bigquery.CreateJoinableViewsForUser(ctx, input.Name, datasources)
	if err != nil {
		return "", err
	}

	for _, d := range datasources {
		dstbl := d.RefDatasource
		if err := r.accessMgr.AddToAuthorizedViews(ctx, dstbl.ProjectID, dstbl.Dataset, projectID, joinableDatasetID, joinableViewsMap[dstbl.DatasetID]); err != nil {
			return "", fmt.Errorf("Failed to add to authorized views: %v", err)
		}
		if err := r.accessMgr.AddToAuthorizedViews(ctx, projectID, "secrets_vault", projectID, joinableDatasetID, joinableViewsMap[dstbl.DatasetID]); err != nil {
			return "", fmt.Errorf("Failed to add to secrets' authorized views: %v", err)
		}
	}

	subj := user.Email
	subjType := models.SubjectTypeUser
	subjWithType := subjType.String() + ":" + subj

	for _, v := range joinableViewsMap {
		if err := r.accessMgr.Grant(ctx, projectID, joinableDatasetID, v, subjWithType); err != nil {
			return "", err
		}
	}

	if _, err := r.repo.CreateJoinableViews(ctx, joinableDatasetID, user.Email, pseudoDatasourceIDs); err != nil {
		return "", err
	}

	return joinableDatasetID, nil
}

// JoinableViews is the resolver for the joinableViews field.
func (r *queryResolver) JoinableViews(ctx context.Context) ([]*models.JoinableView, error) {
	user := auth.GetUser(ctx)
	jviewsDB, err := r.repo.GetJoinableViewsForUser(ctx, user.Email)
	if err != nil {
		return nil, err
	}
	return r.JoinableViewsDBToGraph(jviewsDB), nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) JoinableViewsDBToGraph(jviewsDB []*database.JoinableView) []*models.JoinableView {
	jviews := []*models.JoinableView{}
	for _, v := range jviewsDB {
		jviews = append(jviews, r.JoinableViewDBToGraph(v))
	}
	return jviews
}
func (r *queryResolver) JoinableViewDBToGraph(jviewDB *database.JoinableView) *models.JoinableView {
	jview := &models.JoinableView{
		ID:               jviewDB.ID,
		Name:             jviewDB.Name,
		Created:          jviewDB.Created,
		BigQueryViewUrls: []string{},
	}

	for _, v := range jviewDB.PseudoDatasources {
		jview.BigQueryViewUrls = append(jview.BigQueryViewUrls, r.bigquery.MakeBigQueryUrlForJoinableViews(jviewDB.Name, v.ProjectID, v.Dataset, v.Table))
	}
	return jview
}
